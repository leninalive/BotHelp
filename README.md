# Тестовое задание для BotHelp от Юрия Егорова

Данное тестовое задание является примером очереди, основанной на Redis. Основной код очереди находится в классе `App\Service\RedisQueue`.

## Системные требования

- Docker >= 18.06.0
- Docker Compose

## Установка и запуск

Для установки и запуска тестового задания выполните следующие команды:

```shell
git clone https://github.com/leninalive/BotHelp.git bothelp-ivegorov
cd bothelp-ivegorov
bin/start
```

Для просмотра логов воркеров после запуска воспользуйтесь командой:

```shell
docker-compose logs --tail=11000 -f worker
```

Для остановки воркеров и редиса после окончания работы выполните:

```shell
docker-compose down
```

## TODO

Из-за ограниченного времени в рамках данного тестового задания не сделан некоторый дополнительный (не влияющий на правильность выполнения и/или не оговоренный в условиях) функционал:

1. **Масштабирование и отказоустойчивость** - в настоящий момент воркер корректно масштабируется только в рамках одной машины. Для большего горизонтального масштабирования необходимо также использовать Redis Cluster, для этого нужно:
    
    - Скорректировать docker-compose.yml
    - Изменить методы `RedisQueue::get*QueueKeyName` для того, чтобы корректно работала команда `RPOPLPUSH` в рамках одного `clientId` (используя фигурные скобки)
    - Использовать класс RedisCluster вместо Redis для подключения к кластеру
    - Обеспечить сохранение данных из редиса на диск путем пробрасывания volume'ов в `docker-compose.yml` для сервиса `redis` и использовать опции `appendonly yes`
    
2. **Покрыть код тестами** - написание юнит- и функциональных тестов для подобного кода само по себе является достаточно трудоемкой задачей, явно выходящей за отведенные для выполнения теста временные рамки (6-8 часов)

3. **Использовать Symfony Messenger** - на момент выполнения тестового задания Symfony Messenger все еще является немного "сырым" компонентом с некоторыми нюансами, решение которых может потребовать избыточного времени. Кроме того, моей задачей было показать возможность реализовать необходимый функционал очереди самостоятельно, а не использовать решение из коробки. Кроме того, одним из условий было обеспечить максимальную производительно, в то время, как использование Messenger может накладывать overhead из-за допольнительного использования EventDispatcher.